from util import Utilty
import msgpack
import http.client
import random

# Metasploit interface.
class Msgrpc:
    def __init__(self, option={}, msgrpc_user=None, msgrpc_pass=None, timeout=None, con_retry=None):
        self.host = option.get('host') or "127.0.0.1"
        self.port = option.get('port') or 55552
        self.uri = option.get('uri') or "/api/"
        self.ssl = option.get('ssl') or False
        self.authenticated = False
        self.token = False
        self.headers = {"Content-type": "binary/message-pack"}

        if self.ssl:
            self.client = http.client.HTTPSConnection(self.host, self.port)
        else:
            self.client = http.client.HTTPConnection(self.host, self.port)

        self.util = Utilty()
        self.console_id = 0
    # Call RPC API.
    def call(self, meth, option=[]):
        try:    
            # Set API option.
            option = self.set_api_option(meth, option)
            # Send request.
            resp = self.send_request(meth, option)
            return msgpack.unpackb(resp.read())
        except Exception as e:
            self.util.print_exception(e, 'Failed: msfcall')
            exit(1)

    def set_api_option(self, meth, option):
        try:    
            if meth == 'console.create' or meth == 'job.list' or meth == 'session.list' or meth == 'module.payloads':
                option = []
            if meth != 'auth.login':
                if not self.authenticated:
                    self.util.print_message('fail', 'MsfRPC: Not Authenticated.')
                    exit(1)
            if meth != 'auth.login':
                option.insert(0, self.token)
            option.insert(0, meth)
            return option
        except Exception as e:
            self.util.print_exception(e, 'Failed: set api option')
            exit(1)

    # Send HTTP request.
    def send_request(self, meth, option):
        try:
            params = msgpack.packb(option)
            resp = ''

            self.client.request("POST", self.uri, params, self.headers)
            resp = self.client.getresponse()
        except Exception as err:
            while True:
                # Retry.
                self.util.print_message('warn', 'Retry "{}" call. reason: {}'.format(option[0], err))
                resp = self.send_request(meth, option) 
                break
        return resp

    # Log in to RPC Server.
    def login(self, user, password):
        try:
            ret = self.call('auth.login', [user, password])

            if ret.get(b'result') == b'success':
                self.authenticated = True
                self.token = ret[b'token']

                return True
            else:
                self.util.print_message('fail', 'MsfRPC: Authentication failed.')
                exit(1)
        except Exception as e:
            self.util.print_exception(e, 'Failed: auth.login')
            exit(1)

    #Create MSFconsole.  
    def get_console(self):
        try:
            # Create a console.
            ret = self.call('console.create')
            self.console_id = ret.get(b'id')

            return self.console_id
        except Exception as err:
            self.util.print_exception(err, 'get_console Failed: console.create')
            exit(1)

    # Get all modules.
    def get_module_list(self, module_type):
        try:
            ret = {}
            if module_type == 'exploit':
                ret = self.call('module.exploits')
            elif module_type == 'auxiliary':
                ret = self.call('module.auxiliary')
            elif module_type == 'post':
                ret = self.call('module.post')
            elif module_type == 'payload':
                ret = self.call('module.payloads')
            elif module_type == 'encoder':
                ret = self.call('module.encoders')
            elif module_type == 'nop':
                ret = self.call('module.nops')

            byte_list = ret[b'modules']
            string_list = []

            for module in byte_list:
                string_list.append(module.decode('utf-8'))

            return string_list
        except Exception as e:
            self.util.print_exception(e, 'Failed: Getting {} module list.'.format(module_type))
            exit(1)

    # Get module detail information.
    def get_module_info(self, module_type, module_name):
        return self.call('module.info', [module_type, module_name])

    # Get payload that compatible module.
    def get_compatible_payload_list(self, module_name):
        try:
            ret = self.call('module.compatible_payloads', [module_name])
            byte_list = ret[b'payloads']
            string_list = []

            for module in byte_list:
                string_list.append(module.decode('utf-8'))

            return string_list
        except Exception as e:
            self.util.print_exception(e, 'Failed: module.compatible_payloads.')
            return []

    # Get payload that compatible target.
    def get_target_compatible_payload_list(self, module_name, target_num):
        try:
            ret = self.call('module.target_compatible_payloads', [module_name, target_num])
            byte_list = ret[b'payloads']
            string_list = []

            for module in byte_list:
                string_list.append(module.decode('utf-8'))
            return string_list
        except Exception as e:
            self.util.print_exception(e, 'Failed: module.target_compatible_payloads.')
            return []

    # Get module options.
    def get_module_options(self, module_type, module_name):
        return self.call('module.options', [module_type, module_name])

    # Execute module.
    def execute_module(self, module_type, module_name, target, selected_payload, rhost, port_num, lhost):
        try:
            options = {}
            options.update({'RHOST' : rhost})
            options.update({'RPORT' : port_num})
            options.update({'TARGET' : int(target)})
            options.update({'LHOST' : lhost})
            options.update({'LPORT' : random.randint(1000, 9999)})

            if selected_payload != '':
                options.update({'PAYLOAD' : selected_payload})

            ret = self.call('module.execute', [module_type, module_name, options])
            job_id = ret[b'job_id']
            uuid = ret[b'uuid'].decode('utf-8')

            return job_id, uuid
        except Exception as e:
            if ret[b'error_code'] == 401:
                self.login(msgrpc_user, msgrpc_pass)
            else:
                self.util.print_exception(e, 'Failed: module.execute.')
                exit(1)

    # Get job list.
    def get_job_list(self):
        try:
            jobs = self.call('job.list')
            byte_list = jobs.keys()
            job_list = []

            for job_id in byte_list:
                job_list.append(int(job_id.decode('utf-8')))

            return job_list
        except Exception as e:
            self.util.print_exception(e, 'get_job_list Failed: job.list.')
            return []

    # Get job detail information.
    def get_job_info(self, job_id):
        return self.call('job.info', [job_id])

    # Stop job.
    def stop_job(self, job_id):
        return self.call('job.stop', [job_id])

    # Get session list.
    def get_session_list(self):
        return self.call('session.list')

    # Stop session.
    def stop_session(self, session_id):
        self.call('session.stop', [str(session_id)])

    # Stop meterpreter session.
    def stop_meterpreter_session(self, session_id):
        self.call('session.meterpreter_session_detach', [str(session_id)])

    # Execute shell.
    def execute_shell(self, session_id, cmd):
        try:
            ret = self.call('session.shell_write', [str(session_id), cmd])

            return ret[b'write_count'].decode('utf-8')
        except Exception as e:
            self.util.print_exception(e, 'Failed: {}'.format(cmd))
            return 'Failed'

    # Get executing shell result.
    def get_shell_result(self, session_id, read_pointer):
        try:
            ret = self.call('session.shell_read', [str(session_id), read_pointer])
            seq = ret[b'seq'].decode('utf-8')
            data = ret[b'data'].decode('utf-8')

            return seq, data
        except Exception as e:
            self.util.print_exception(e, 'Failed: session.shell_read.')
            return 0, 'Failed'

    # Execute meterpreter.
    def execute_meterpreter(self, session_id, cmd):
        try:
            ret = self.call('session.meterpreter_write', [str(session_id), cmd])
            return ret[b'result'].decode('utf-8')
        except Exception as e:
            self.util.print_exception(e, 'Failed: {}'.format(cmd))
            return 'Failed'

    # Execute single meterpreter.
    def execute_meterpreter_run_single(self, session_id, cmd):
        try:
            ret = self.call('session.meterpreter_run_single', [str(session_id), cmd])
            return ret[b'result'].decode('utf-8')
        except Exception as e:
            self.util.print_exception(e, 'Failed: {}'.format(cmd))
            return 'Failed'

    # Get executing meterpreter result.
    def get_meterpreter_result(self, session_id):
        try:
            ret = self.call('session.meterpreter_read', [str(session_id)])
            return ret[b'data'].decode('utf-8')
        except Exception as e:
            self.util.print_exception(e, 'Failed: session.meterpreter_read')
            return None

    # Upgrade shell session to meterpreter.
    def upgrade_shell_session(self, session_id, lhost, lport):
        try:
            ret = self.call('session.shell_upgrade', [str(session_id), lhost, lport])
            return ret[b'result'].decode('utf-8')
        except Exception as e:
            self.util.print_exception(e, 'Failed: session.shell_upgrade')
            return 'Failed'
           
    # Log out from RPC Server.
    def logout(self):
        try:
            ret = self.call('auth.logout', [self.token])

            if ret.get(b'result') == b'success':
                self.authenticated = False
                self.token = ''
                return True
            else:
                self.util.print_message('fail', 'MsfRPC: Authentication failed.')
                exit(1)
        except Exception as e:
            self.util.print_exception(e, 'Failed: auth.logout')
            exit(1)

    # Disconnection.
    def termination(self, console_id):
        # Kill a console and Log out.
        self.call('console.session_kill', [console_id])
        self.logout()
